<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Setting Up Your Own Recursive DNS Server | Martin Kubečka</title><meta name=keywords content="unbound,pi-hole,privacy,self-hosting"><meta name=description content="Learn how to set up your own Recursive DNS Server at home on a Raspberry Pi 4."><meta name=author content="Martin Kubečka"><link rel=canonical href=https://martinkubecka.sk/posts/resursive_dns/><link crossorigin=anonymous href=/assets/css/stylesheet.ba00c1f715cc18cbf534f1dd7be1b22fc29e5384ca42c46b68ff6c99b2b92143.css integrity="sha256-ugDB9xXMGMv1NPHde+GyL8KeU4TKQsRraP9smbK5IUM=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://martinkubecka.sk/images/favicon/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://martinkubecka.sk/images/favicon/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://martinkubecka.sk/images/favicon/favicon-32x32.png><link rel=apple-touch-icon href=https://martinkubecka.sk/images/favicon/apple-touch-icon.png><link rel=mask-icon href=https://martinkubecka.sk/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Setting Up Your Own Recursive DNS Server"><meta property="og:description" content="Learn how to set up your own Recursive DNS Server at home on a Raspberry Pi 4."><meta property="og:type" content="article"><meta property="og:url" content="https://martinkubecka.sk/posts/resursive_dns/"><meta property="og:image" content="https://martinkubecka.sk/images/general/recursive_dns/icon.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-01-28T00:00:00+00:00"><meta property="article:modified_time" content="2022-01-28T00:00:00+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://martinkubecka.sk/images/general/recursive_dns/icon.png"><meta name=twitter:title content="Setting Up Your Own Recursive DNS Server"><meta name=twitter:description content="Learn how to set up your own Recursive DNS Server at home on a Raspberry Pi 4."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://martinkubecka.sk/posts/"},{"@type":"ListItem","position":3,"name":"Setting Up Your Own Recursive DNS Server","item":"https://martinkubecka.sk/posts/resursive_dns/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Setting Up Your Own Recursive DNS Server","name":"Setting Up Your Own Recursive DNS Server","description":"Learn how to set up your own Recursive DNS Server at home on a Raspberry Pi 4.","keywords":["unbound","pi-hole","privacy","self-hosting"],"articleBody":"Introduction Unbound is a validating, recursive, caching open-source DNS resolver primarily developed by NLnet Labs, VeriSign Inc., Nominet, and Kirei. To help increase our online privacy, unbound supports DNS-over-TLS and DNS-over-HTTPS which allows clients to encrypt their communication. Unbound runs on FreeBSD, OpenBSD, NetBSD, MacOS, Linux and Microsoft Windows, with packages available for most platforms.\nThis guide is intended for unbound installation in conjunction with Pi-hole and therefore Pi-hole is the only prerequisite.\n The Pi-hole is a DNS sinkhole that protects your devices from unwanted content, without installing any client-side software. (documentation)\n You can install and configure Pi-hole with the command below on any distribution which utilizes systemd or sysvinit. To verify if your distribution is supported, check out Supported Operating Systems section in the Pi-hole documentation. This guide will not go through the Pi-hole installation steps.\n$ curl -sSL https://install.pi-hole.net | bash Personal setup We decided to install unbound on a dedicated system connected directly to our router via ethernet. Here is the complete list of hardware and accessories we have used for this project:\n Raspberry Pi 4 Model B (4GB RAM)  OS : Raspberry Pi OS Lite (32-bit)   Raspberry Pi 15W USB-C Power Supply Flirc Raspberry Pi 4 Case SanDisk micro SDHC 32 GB Extreme Pro  If you are familiar with how does DNS and unbound work, feel free to skip to the Installation section.\n How does it actually work? In this section, we will learn how does DNS work, what is the difference between recursive and iterative DNS resolver, how does unbound work and what are the pros and the cons of running your own recursive DNS resolver at home.\nHow does DNS actually work? After a user types a domain name (e.g. “thehackernews.com”) into their browser, DNS lookup is triggered. A group of DNS servers then help to find the IP address for the domain and return it back to the user’s computer.\nBecause we will be installing and setting up unbound as a recursive DNS resolver, let’s talk about the difference between recursive and iterative DNS resolver.\nRecursive DNS resolver is a middleman between a client (you) and a DNS nameserver. This type of a DNS resolver is recursively querying other DNS servers until it has an IP address for the requested domain, which is returned to the client. If a DNS resolver has already performed the same query in the recent past, this DNS query is cached and when performed again, our resolver respond to us with the cashed data instead of querying other DNS servers.\nHere are other DNS servers that are queried when using a recursive DNS resolver:\n DNS root nameserver  responds by directing the recursive resolver to a TLD nameserver, based on the extension of that domain (.com, .net, .org, etc.)   DNS TLD nameserver  maintains information for all the domain names that share a common domain extension (.com, .net, .org, etc.)   DNS authoritative nameserver  contains information specific to the domain name it serves and it also provides a recursive resolver with the IP address of that server found in the DNS A record if the domain has a CNAME record it will provide the recursive resolver with an alias domain which means the recursive resolver will have to perform a new DNS lookup for this record    Let’s visualize what a DNS lookup looks like when a client is using a recursive DNS resolver.\nOn the other hand, when using an iterative DNS resolver client will allow a DNS server to return the best answer it can. If the queried DNS server does not have a match for the query name, it will return a referral to a DNS server authoritative for a lower level of the domain namespace. The DNS client will then make a query to the referral address. This process continues with additional DNS servers down the query chain until either an error or timeout occurs.\nNow let’s visualize what a DNS lookup looks like when a client is using a iterative DNS resolver.\nHow does unbound work? In a few steps below, we will describe what are the differences when running only a Pi-hole and a Pi-hole with unbound.\n  Standard Pi-hole configuration:\n Client asks the Pi-hole who is domain.com . Pi-hole will check its cache and reply if the answer is known. Pi-hole will check the blocking lists and reply if the domain is blocked. If neither 2. nor 3. point is true, the Pi-hole forwards the DNS request to the configured upstream DNS (usually it is default one from your ISP) When Pi-hole receives the answer, it will reply to a client with the answer. Lastly, Pi-hole will cache the answer so it will be able to respond faster next time a client queries the same domain.    Pi-hole setup with unbound as a local recursive DNS resolver:\n Client asks the Pi-hole who is domain.com . Pi-hole will check its cache and reply if the answer is known. Pi-hole will check the blocking lists and reply if the domain is blocked. If neither 2. nor 3. point is true, the Pi-hole forwards the DNS request to the local recursive DNS resolver = unbound. Unbound will send a query to the DNS root servers asking who is handling .com . The root server answers with a referral to the TLD (Top level domain) server for .com . Unbound will send a query to one of the TLD DNS server for .com asking who is handling domain.com . The TLD server answers with a referral to the authoritative name servers for domain.com . Unbound will send a query to the authoritative name servers asking what is the IP for domain.com . The authoritative server will answer with the IP address of the domain domain.com . Unbound will send the reply to Pi-hole which will reply with the answer to a client. Lastly, Pi-hole will cache the answer so it will be able to respond faster next time a client queries the same domain.    Pros and Cons  Pros  Privacy : Directly contacting the responsive servers means that no server can fully log the exact paths you’re going (e.g. Google DNS servers will only be asked if you want to visit a Google website).   Cons  When traversing the path for the first, especially visiting a website for the first time, it may be slower than when we are using big DNS providers which have answers for common used domains cached. The first request to a formerly unknown TLD may take up to a second. Subsequent requests to domains under the same TLD usually complete in . Fortunately, our setup will be configured for efficient caching to minimize the number of queries that will actually have to be performed.     Installation Unbound can be simply installed from a package manager with the command below, if you are using apt as a package manager.\n$ sudo apt install unbound Or you can download unbound from Github and then compile and install it with the following command.\n$ ./configure \u0026\u0026 make \u0026\u0026 make install  If you are not installing unbound from a package manager, you have to download the current root hints file (list of primary root servers). After downloading this file, you will need to uncomment the root-hints: configuration line in the suggested config file provided below.\n$ wget https://www.internic.net/domain/named.root -qO- | sudo tee /var/lib/unbound/root.hints\nAdd a cronjob or run this command roughly every six months to update the root.hints file.\n  Configuration Now we need to create a config file called pi-hole.conf in /etc/unbound/unbound.conf.d/ directory. Run the following command to create such a file and then copy the content of suggested config file provided to us from an official unbound documentation.\n$ sudo nano /etc/unbound/unbound.conf.d/pi-hole.conf Suggested config file\n# Unbound config file server: # If no logfile is specified, syslog is used # logfile: \"/var/log/unbound/unbound.log\" verbosity: 0 interface: 127.0.0.1 port: 5335 do-ip4: yes do-udp: yes do-tcp: yes # May be set to yes if you have IPv6 connectivity do-ip6: no # You want to leave this to no unless you have *native* IPv6. With 6to4 and # Terredo tunnels your web browser should favor IPv4 for the same reasons prefer-ip6: no # Use this only when you downloaded the list of primary root servers! # If you use the default dns-root-data package, unbound will find it automatically #root-hints: \"/var/lib/unbound/root.hints\" # Trust glue only if it is within the server's authority harden-glue: yes # Require DNSSEC data for trust-anchored zones, if such data is absent, the zone becomes BOGUS harden-dnssec-stripped: yes # Don't use Capitalization randomization as it known to cause DNSSEC issues sometimes # see https://discourse.pi-hole.net/t/unbound-stubby-or-dnscrypt-proxy/9378 for further details use-caps-for-id: no # Reduce EDNS reassembly buffer size. # IP fragmentation is unreliable on the Internet today, and can cause # transmission failures when large DNS messages are sent via UDP. Even # when fragmentation does work, it may not be secure; it is theoretically # possible to spoof parts of a fragmented DNS message, without easy # detection at the receiving end. Recently, there was an excellent study #  Defragmenting DNS - Determining the optimal maximum UDP response size for DNS # by Axel Koolhaas, and Tjeerd Slokker (https://indico.dns-oarc.net/event/36/contributions/776/) # in collaboration with NLnet Labs explored DNS using real world data from the # the RIPE Atlas probes and the researchers suggested different values for # IPv4 and IPv6 and in different scenarios. They advise that servers should # be configured to limit DNS messages sent over UDP to a size that will not # trigger fragmentation on typical network links. DNS servers can switch # from UDP to TCP when a DNS response is too big to fit in this limited # buffer size. This value has also been suggested in DNS Flag Day 2020. edns-buffer-size: 1232 # Perform prefetching of close to expired message cache entries # This only applies to domains that have been frequently queried prefetch: yes # One thread should be sufficient, can be increased on beefy machines. In reality for most users running on small networks or on a single machine, it should be unnecessary to seek performance enhancement by increasing num-threads above 1. num-threads: 1 # Ensure kernel buffer is large enough to not lose messages in traffic spikes so-rcvbuf: 1m # Ensure privacy of local IP ranges private-address: 192.168.0.0/16 private-address: 169.254.0.0/16 private-address: 172.16.0.0/12 private-address: 10.0.0.0/8 private-address: fd00::/8 private-address: fe80::/10 After saving pi-hole.conf configuration file, we will start our local DNS recursive server with the command below.\n$ sudo service unbound restart Testing DNS lookup Finally, we will test our unbound recursive DNS resolver with a dig command querying a DNS record for a pi-hole.net domain. Notice status value NOERROR and the IP address for our requested domain.\n$ dig pi-hole.net @127.0.0.1 -p 5335 ;  DiG 9.16.22-Raspbian  pi-hole.net @127.0.0.1 -p 5335 ;; global options: +cmd ;; Got answer: ;; -HEADER;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1 ;; OPT PSEUDOSECTION: ; EDNS: version: 0, flags:; udp: 1232 ;; QUESTION SECTION: ;pi-hole.net. IN A ;; ANSWER SECTION: pi-hole.net. 300 IN A 3.18.136.52 ;; Query time: 19 msec ;; SERVER: 127.0.0.1#5335(127.0.0.1) ;; WHEN: Thu Jan 27 18:41:51 CET 2022 ;; MSG SIZE rcvd: 56 Testing DNSSEC Last step before changing our network settings will be testing DNSSEC validation using once again dig command.\nThe first command should give us a status report of SERVFAIL and no IP address.\n$ dig sigfail.verteiltesysteme.net @127.0.0.1 -p 5335 ;  DiG 9.16.22-Raspbian  sigfail.verteiltesysteme.net @127.0.0.1 -p 5335 ;; global options: +cmd ;; Got answer: ;; -HEADER;; flags: qr rd ra; QUERY: 1, ANSWER: 0, AUTHORITY: 0, ADDITIONAL: 1 ;; OPT PSEUDOSECTION: ; EDNS: version: 0, flags:; udp: 1232 ;; QUESTION SECTION: ;sigfail.verteiltesysteme.net. IN A ;; Query time: 299 msec ;; SERVER: 127.0.0.1#5335(127.0.0.1) ;; WHEN: Thu Jan 27 18:03:00 CET 2022 ;; MSG SIZE rcvd: 57 The second command should give us NOERROR and IP address.\n$ dig sigok.verteiltesysteme.net @127.0.0.1 -p 5335 ;  DiG 9.16.22-Raspbian  sigok.verteiltesysteme.net @127.0.0.1 -p 5335 ;; global options: +cmd ;; Got answer: ;; -HEADER;; flags: qr rd ra ad; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1 ;; OPT PSEUDOSECTION: ; EDNS: version: 0, flags:; udp: 1232 ;; QUESTION SECTION: ;sigok.verteiltesysteme.net. IN A ;; ANSWER SECTION: sigok.verteiltesysteme.net. 60 IN A 134.91.78.139 ;; Query time: 29 msec ;; SERVER: 127.0.0.1#5335(127.0.0.1) ;; WHEN: Thu Jan 27 18:03:15 CET 2022 ;; MSG SIZE rcvd: 71  Pi-hole settings In your Pi-hole web console, navigate to the Settings, then DNS. Make sure to uncheck all upstream DNS servers.\nNow, scroll down to the second Upstream DNS Servers section and specify 127.0.0.1#5335 as the Custom DNS (IPv4). This means that your Pi-hole will use your recursive DNS server provided by unbound.\nAt last, scroll all the way down and save your settings. After pressing the Save button you should see a pop up Info window\n Validating our setup At the time of writing this post, we have been running Pi-hole with unbound for almost 24 hours. We are able to validate that our configuration works from the Upstream servers pie chart, where 65% of all the DNS queries were handled by our local recursive DNS resolver and 20% were cached queries. Remaining 15% of DNS queries were handled by our preconfigured Quad9 upstream server and other public resolver while we were configuring local recursive DNS resolver unbound.\n Resources  Pi-hole - documentation : https://docs.pi-hole.net/ unbound - about : https://nlnetlabs.nl/projects/unbound/about/ unbound - install : https://docs.pi-hole.net/guides/dns/unbound/ What is DNS? : https://www.cloudflare.com/learning/dns/what-is-dns/ What is recursive DNS? : https://www.cloudflare.com/learning/dns/what-is-recursive-dns/ DNS server types : https://www.cloudflare.com/learning/dns/dns-server-types/   Thank you for reading and we hope you learned something new._\n","wordCount":"2286","inLanguage":"en","image":"https://martinkubecka.sk/images/general/recursive_dns/icon.png","datePublished":"2022-01-28T00:00:00Z","dateModified":"2022-01-28T00:00:00Z","author":{"@type":"Person","name":"Martin Kubečka"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://martinkubecka.sk/posts/resursive_dns/"},"publisher":{"@type":"Organization","name":"Martin Kubečka","logo":{"@type":"ImageObject","url":"https://martinkubecka.sk/images/favicon/favicon.ico"}}}</script></head><body id=top><script>window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://martinkubecka.sk accesskey=h title="$ cd /home/ (Alt + H)">$ cd /home/</a><div class=logo-switches></div></div><button id=menu-trigger aria-haspopup=menu aria-label="Menu Button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"/><line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="18" x2="21" y2="18"/></svg></button><ul class="menu hidden"><li><a href=https://martinkubecka.sk/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://martinkubecka.sk/archives title=Archive><span>Archive</span></a></li><li><a href=https://martinkubecka.sk/library/ title=Library><span>Library</span></a></li><li><a href=https://martinkubecka.sk/about/ title=About><span>About</span></a></li><li><a href=https://martinkubecka.sk/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://martinkubecka.sk>Home</a>&nbsp;»&nbsp;<a href=https://martinkubecka.sk/posts/>Posts</a></div><h1 class=post-title>Setting Up Your Own Recursive DNS Server</h1><div class=post-description>Learn how to set up your own Recursive DNS Server at home on a Raspberry Pi 4.</div><div class=post-meta><span title='2022-01-28 00:00:00 +0000 +0000'>January 28, 2022</span>&nbsp;·&nbsp;11 min&nbsp;·&nbsp;2286 words&nbsp;·&nbsp;Martin Kubečka</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#introduction>Introduction</a><ul><li><a href=#personal-setup>Personal setup</a></li></ul></li><li><a href=#how-does-it-actually-work>How does it actually work?</a><ul><li><a href=#how-does-dns-actually-work>How does DNS actually work?</a></li><li><a href=#how-does-unbound-work>How does unbound work?</a></li><li><a href=#pros-and-cons>Pros and Cons</a></li></ul></li><li><a href=#installation>Installation</a></li><li><a href=#configuration>Configuration</a><ul><li><a href=#testing-dns-lookup>Testing DNS lookup</a></li><li><a href=#testing-dnssec>Testing DNSSEC</a></li></ul></li><li><a href=#pi-hole-settings>Pi-hole settings</a></li><li><a href=#validating-our-setup>Validating our setup</a></li><li><a href=#resources>Resources</a></li></ul></nav></div></details></div><div class=post-content><h2 id=introduction>Introduction<a hidden class=anchor aria-hidden=true href=#introduction>#</a></h2><p><a href=https://github.com/NLnetLabs/unbound><em><strong>Unbound</strong></em></a> is a validating, recursive, caching open-source DNS resolver primarily developed by NLnet Labs, VeriSign Inc., Nominet, and Kirei. To help increase our online privacy, <em><strong>unbound</strong></em> supports <a href=https://tools.ietf.org/html/rfc7858>DNS-over-TLS</a> and <a href=https://tools.ietf.org/html/rfc8484>DNS-over-HTTPS</a> which allows clients to encrypt their communication. <em><strong>Unbound</strong></em> runs on FreeBSD, OpenBSD, NetBSD, MacOS, Linux and Microsoft Windows, with <a href=https://repology.org/metapackage/unbound/versions>packages</a> available for most platforms.</p><p>This guide is intended for <em><strong>unbound</strong></em> installation in conjunction with <em><strong>Pi-hole</strong></em> and therefore <em><strong>Pi-hole</strong></em> is the only prerequisite.</p><blockquote><p>The Pi-hole is a DNS sinkhole that protects your devices from unwanted content, without installing any client-side software. (<a href=https://docs.pi-hole.net/>documentation</a>)</p></blockquote><p>You can install and configure <em><strong>Pi-hole</strong></em> with the command below on any distribution which utilizes <a href=https://systemd.io/>systemd</a> or <a href=https://www.nongnu.org/sysvinit/>sysvinit</a>. To verify if your distribution is supported, check out <a href=https://docs.pi-hole.net/main/prerequisites/#supported-operating-systems>Supported Operating Systems</a> section in the <em><strong>Pi-hole</strong></em> documentation. This guide will not go through the <em><strong>Pi-hole</strong></em> installation steps.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-console data-lang=console><span class=line><span class=cl><span class=gp>$</span> curl -sSL https://install.pi-hole.net <span class=p>|</span> bash
</span></span></code></pre></div><h3 id=personal-setup>Personal setup<a hidden class=anchor aria-hidden=true href=#personal-setup>#</a></h3><p>We decided to install <em><strong>unbound</strong></em> on a dedicated system connected directly to our router via ethernet. Here is the complete list of hardware and accessories we have used for this project:</p><ul><li><a href=https://www.raspberrypi.com/products/raspberry-pi-4-model-b/>Raspberry Pi 4 Model B</a> (4GB RAM)<ul><li>OS : Raspberry Pi OS Lite (32-bit)</li></ul></li><li><a href=https://www.raspberrypi.com/products/type-c-power-supply/>Raspberry Pi 15W USB-C Power Supply</a></li><li><a href=https://flirc.tv/more/raspberry-pi-4-case>Flirc Raspberry Pi 4 Case</a></li><li>SanDisk micro SDHC 32 GB Extreme Pro</li></ul><p>If you are familiar with how does DNS and <em><strong>unbound</strong></em> work, feel free to skip to the <strong>Installation</strong> section.</p><hr><h2 id=how-does-it-actually-work>How does it actually work?<a hidden class=anchor aria-hidden=true href=#how-does-it-actually-work>#</a></h2><p>In this section, we will learn how does DNS work, what is the difference between <em>recursive</em> and <em>iterative</em> DNS resolver, how does <em><strong>unbound</strong></em> work and what are the pros and the cons of running your own recursive DNS resolver at home.</p><h3 id=how-does-dns-actually-work>How does DNS actually work?<a hidden class=anchor aria-hidden=true href=#how-does-dns-actually-work>#</a></h3><p>After a user types a domain name (e.g. &ldquo;thehackernews.com&rdquo;) into their browser, DNS lookup is triggered. A group of DNS servers then help to find the IP address for the domain and return it back to the user&rsquo;s computer.</p><p>Because we will be installing and setting up <em><strong>unbound</strong></em> as a <em>recursive DNS resolver</em>, let&rsquo;s talk about the difference between <em>recursive</em> and <em>iterative</em> DNS resolver.</p><p><em>Recursive DNS resolver</em> is a middleman between a client (you) and a DNS nameserver. This type of a DNS resolver is recursively querying other DNS servers until it has an IP address for the requested domain, which is returned to the client. If a DNS resolver has already performed the same query in the recent past, this DNS query is cached and when performed again, our resolver respond to us with the cashed data instead of querying other DNS servers.</p><p>Here are other DNS servers that are queried when using a recursive DNS resolver:</p><ol><li><strong>DNS root nameserver</strong><ul><li>responds by directing the recursive resolver to a TLD nameserver, based on the extension of that domain (.com, .net, .org, etc.)</li></ul></li><li><strong>DNS TLD nameserver</strong><ul><li>maintains information for all the domain names that share a common domain extension (.com, .net, .org, etc.)</li></ul></li><li><strong>DNS authoritative nameserver</strong><ul><li>contains information specific to the domain name it serves and it also provides a recursive resolver with the IP address of that server found in the <a href=https://www.cloudflare.com/learning/dns/dns-records/dns-a-record/>DNS A record</a></li><li>if the domain has a <a href=https://www.cloudflare.com/learning/dns/dns-records/dns-cname-record/>CNAME record</a> it will provide the recursive resolver with an alias domain which means the recursive resolver will have to perform a new DNS lookup for this record</li></ul></li></ol><p>Let&rsquo;s visualize what a DNS lookup looks like when a client is using a <em>recursive DNS resolver</em>.</p><p><img loading=lazy src=/images/general/recursive_dns/Recursive_DNS_resolver.png alt title="Recursive DNS resolver"></p><p>On the other hand, when using an <em>iterative DNS resolver</em> client will allow a DNS server to return the best answer it can. If the queried DNS server does not have a match for the query name, it will return a referral to a DNS server authoritative for a lower level of the domain namespace. The DNS client will then make a query to the referral address. This process continues with additional DNS servers down the query chain until either an error or timeout occurs.</p><p>Now let&rsquo;s visualize what a DNS lookup looks like when a client is using a <em>iterative DNS resolver</em>.</p><p><img loading=lazy src=/images/general/recursive_dns/Iterative_DNS_resolver.png alt title="Iterative DNS resolver"></p><h3 id=how-does-unbound-work>How does unbound work?<a hidden class=anchor aria-hidden=true href=#how-does-unbound-work>#</a></h3><p>In a few steps below, we will describe what are the differences when running only a <em><strong>Pi-hole</strong></em> and a <em><strong>Pi-hole</strong></em> with <em><strong>unbound</strong></em>.</p><ul><li><p>Standard <em><strong>Pi-hole</strong></em> configuration:</p><ol><li>Client asks the <em><strong>Pi-hole</strong></em> who is <code>domain.com</code> .</li><li><em><strong>Pi-hole</strong></em> will check its cache and reply if the answer is known.</li><li><em><strong>Pi-hole</strong></em> will check the blocking lists and reply if the domain is blocked.</li><li>If neither 2. nor 3. point is true, the <em><strong>Pi-hole</strong></em> forwards the DNS request to the configured upstream DNS (usually it is default one from your ISP)</li><li>When <em><strong>Pi-hole</strong></em> receives the answer, it will reply to a client with the answer.</li><li>Lastly, <em><strong>Pi-hole</strong></em> will cache the answer so it will be able to respond faster next time a client queries the same domain.</li></ol></li><li><p><em><strong>Pi-hole</strong></em> setup with <em><strong>unbound</strong></em> as a local recursive DNS resolver:</p><ol><li>Client asks the <em><strong>Pi-hole</strong></em> who is <code>domain.com</code> .</li><li><em><strong>Pi-hole</strong></em> will check its cache and reply if the answer is known.</li><li><em><strong>Pi-hole</strong></em> will check the blocking lists and reply if the domain is blocked.</li><li>If neither 2. nor 3. point is true, the <em><strong>Pi-hole</strong></em> forwards the DNS request to the local recursive DNS resolver = <em><strong>unbound</strong></em>.</li><li><em><strong>Unbound</strong></em> will send a query to the DNS root servers asking who is handling <code>.com</code> .</li><li>The root server answers with a referral to the TLD (Top level domain) server for <code>.com</code> .</li><li><em><strong>Unbound</strong></em> will send a query to one of the TLD DNS server for <code>.com</code> asking who is handling <code>domain.com</code> .</li><li>The TLD server answers with a referral to the authoritative name servers for <code>domain.com</code> .</li><li><em><strong>Unbound</strong></em> will send a query to the authoritative name servers asking what is the IP for <code>domain.com</code> .</li><li>The authoritative server will answer with the IP address of the domain <code>domain.com</code> .</li><li><em><strong>Unbound</strong></em> will send the reply to <em><strong>Pi-hole</strong></em> which will reply with the answer to a client.</li><li>Lastly, <em><strong>Pi-hole</strong></em> will cache the answer so it will be able to respond faster next time a client queries the same domain.</li></ol></li></ul><h3 id=pros-and-cons>Pros and Cons<a hidden class=anchor aria-hidden=true href=#pros-and-cons>#</a></h3><ul><li><strong>Pros</strong><ul><li><em>Privacy</em> : Directly contacting the responsive servers means that no server can fully log the exact paths you&rsquo;re going (e.g. Google DNS servers will only be asked if you want to visit a Google website).</li></ul></li><li><strong>Cons</strong><ul><li>When traversing the path for the first, especially visiting a website for the first time, it may be slower than when we are using big DNS providers which have answers for common used domains cached. The first request to a formerly unknown TLD may take up to a second. Subsequent requests to domains under the same TLD usually complete in <strong>&lt; 0.1s</strong>. Fortunately, our setup will be configured for efficient caching to minimize the number of queries that will actually have to be performed.</li></ul></li></ul><hr><h2 id=installation>Installation<a hidden class=anchor aria-hidden=true href=#installation>#</a></h2><p><em><strong>Unbound</strong></em> can be simply installed from a package manager with the command below, if you are using <code>apt</code> as a package manager.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-console data-lang=console><span class=line><span class=cl><span class=gp>$</span> sudo apt install unbound
</span></span></code></pre></div><p>Or you can download <em><strong>unbound</strong></em> from <a href=https://github.com/NLnetLabs/unbound>Github</a> and then compile and install it with the following command.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-console data-lang=console><span class=line><span class=cl><span class=gp>$</span> ./configure <span class=o>&amp;&amp;</span> make <span class=o>&amp;&amp;</span> make install
</span></span></code></pre></div><blockquote><p>If you are not installing <em><strong>unbound</strong></em> from a package manager, you have to download the current root hints file (list of primary root servers). After downloading this file, you will need to uncomment the <code>root-hints:</code> configuration line in the suggested config file provided below.</p><p><code>$ wget https://www.internic.net/domain/named.root -qO- | sudo tee /var/lib/unbound/root.hints</code></p><p>Add a cronjob or run this command roughly every six months to update the <strong>root.hints</strong> file.</p></blockquote><hr><h2 id=configuration>Configuration<a hidden class=anchor aria-hidden=true href=#configuration>#</a></h2><p>Now we need to create a config file called <code>pi-hole.conf</code> in <code>/etc/unbound/unbound.conf.d/</code> directory. Run the following command to create such a file and then copy the content of <a href=https://docs.pi-hole.net/guides/dns/unbound/#configure-unbound>suggested config file</a> provided to us from an official <em><strong>unbound</strong></em> documentation.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-console data-lang=console><span class=line><span class=cl><span class=gp>$</span> sudo nano /etc/unbound/unbound.conf.d/pi-hole.conf
</span></span></code></pre></div><p><strong>Suggested config file</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-console data-lang=console><span class=line><span class=cl><span class=gp>#</span> Unbound config file
</span></span><span class=line><span class=cl><span class=go>server:
</span></span></span><span class=line><span class=cl><span class=go>    # If no logfile is specified, syslog is used
</span></span></span><span class=line><span class=cl><span class=go>    # logfile: &#34;/var/log/unbound/unbound.log&#34;
</span></span></span><span class=line><span class=cl><span class=go>    verbosity: 0
</span></span></span><span class=line><span class=cl><span class=go></span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=go>    interface: 127.0.0.1
</span></span></span><span class=line><span class=cl><span class=go>    port: 5335
</span></span></span><span class=line><span class=cl><span class=go>    do-ip4: yes
</span></span></span><span class=line><span class=cl><span class=go>    do-udp: yes
</span></span></span><span class=line><span class=cl><span class=go>    do-tcp: yes
</span></span></span><span class=line><span class=cl><span class=go></span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=go>    # May be set to yes if you have IPv6 connectivity
</span></span></span><span class=line><span class=cl><span class=go>    do-ip6: no
</span></span></span><span class=line><span class=cl><span class=go></span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=go>    # You want to leave this to no unless you have *native* IPv6. With 6to4 and
</span></span></span><span class=line><span class=cl><span class=go>    # Terredo tunnels your web browser should favor IPv4 for the same reasons
</span></span></span><span class=line><span class=cl><span class=go>    prefer-ip6: no
</span></span></span><span class=line><span class=cl><span class=go></span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=go>    # Use this only when you downloaded the list of primary root servers!
</span></span></span><span class=line><span class=cl><span class=go>    # If you use the default dns-root-data package, unbound will find it automatically
</span></span></span><span class=line><span class=cl><span class=go>    #root-hints: &#34;/var/lib/unbound/root.hints&#34;
</span></span></span><span class=line><span class=cl><span class=go></span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=go>    # Trust glue only if it is within the server&#39;s authority
</span></span></span><span class=line><span class=cl><span class=go>    harden-glue: yes
</span></span></span><span class=line><span class=cl><span class=go></span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=go>    # Require DNSSEC data for trust-anchored zones, if such data is absent, the zone becomes BOGUS
</span></span></span><span class=line><span class=cl><span class=go>    harden-dnssec-stripped: yes
</span></span></span><span class=line><span class=cl><span class=go></span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=go>    # Don&#39;t use Capitalization randomization as it known to cause DNSSEC issues sometimes
</span></span></span><span class=line><span class=cl><span class=go>    # see https://discourse.pi-hole.net/t/unbound-stubby-or-dnscrypt-proxy/9378 for further details
</span></span></span><span class=line><span class=cl><span class=go>    use-caps-for-id: no
</span></span></span><span class=line><span class=cl><span class=go></span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=go>    # Reduce EDNS reassembly buffer size.
</span></span></span><span class=line><span class=cl><span class=go>    # IP fragmentation is unreliable on the Internet today, and can cause
</span></span></span><span class=line><span class=cl><span class=go>    # transmission failures when large DNS messages are sent via UDP. Even
</span></span></span><span class=line><span class=cl><span class=go>    # when fragmentation does work, it may not be secure; it is theoretically
</span></span></span><span class=line><span class=cl><span class=go>    # possible to spoof parts of a fragmented DNS message, without easy
</span></span></span><span class=line><span class=cl><span class=go>    # detection at the receiving end. Recently, there was an excellent study
</span></span></span><span class=line><span class=cl><span class=go>    # &gt;&gt;&gt; Defragmenting DNS - Determining the optimal maximum UDP response size for DNS &lt;&lt;&lt;
</span></span></span><span class=line><span class=cl><span class=go>    # by Axel Koolhaas, and Tjeerd Slokker (https://indico.dns-oarc.net/event/36/contributions/776/)
</span></span></span><span class=line><span class=cl><span class=go>    # in collaboration with NLnet Labs explored DNS using real world data from the
</span></span></span><span class=line><span class=cl><span class=go>    # the RIPE Atlas probes and the researchers suggested different values for
</span></span></span><span class=line><span class=cl><span class=go>    # IPv4 and IPv6 and in different scenarios. They advise that servers should
</span></span></span><span class=line><span class=cl><span class=go>    # be configured to limit DNS messages sent over UDP to a size that will not
</span></span></span><span class=line><span class=cl><span class=go>    # trigger fragmentation on typical network links. DNS servers can switch
</span></span></span><span class=line><span class=cl><span class=go>    # from UDP to TCP when a DNS response is too big to fit in this limited
</span></span></span><span class=line><span class=cl><span class=go>    # buffer size. This value has also been suggested in DNS Flag Day 2020.
</span></span></span><span class=line><span class=cl><span class=go>    edns-buffer-size: 1232
</span></span></span><span class=line><span class=cl><span class=go></span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=go>    # Perform prefetching of close to expired message cache entries
</span></span></span><span class=line><span class=cl><span class=go>    # This only applies to domains that have been frequently queried
</span></span></span><span class=line><span class=cl><span class=go>    prefetch: yes
</span></span></span><span class=line><span class=cl><span class=go></span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=go>    # One thread should be sufficient, can be increased on beefy machines. In reality for most users running on small networks or on a single machine, it should be unnecessary to seek performance enhancement by increasing num-threads above 1.
</span></span></span><span class=line><span class=cl><span class=go>    num-threads: 1
</span></span></span><span class=line><span class=cl><span class=go></span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=go>    # Ensure kernel buffer is large enough to not lose messages in traffic spikes
</span></span></span><span class=line><span class=cl><span class=go>    so-rcvbuf: 1m
</span></span></span><span class=line><span class=cl><span class=go></span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=go>    # Ensure privacy of local IP ranges
</span></span></span><span class=line><span class=cl><span class=go>    private-address: 192.168.0.0/16
</span></span></span><span class=line><span class=cl><span class=go>    private-address: 169.254.0.0/16
</span></span></span><span class=line><span class=cl><span class=go>    private-address: 172.16.0.0/12
</span></span></span><span class=line><span class=cl><span class=go>    private-address: 10.0.0.0/8
</span></span></span><span class=line><span class=cl><span class=go>    private-address: fd00::/8
</span></span></span><span class=line><span class=cl><span class=go>    private-address: fe80::/10
</span></span></span></code></pre></div><p>After saving <code>pi-hole.conf</code> configuration file, we will start our local DNS recursive server with the command below.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-console data-lang=console><span class=line><span class=cl><span class=gp>$</span> sudo service unbound restart
</span></span></code></pre></div><h3 id=testing-dns-lookup>Testing DNS lookup<a hidden class=anchor aria-hidden=true href=#testing-dns-lookup>#</a></h3><p>Finally, we will test our <em><strong>unbound</strong></em> recursive DNS resolver with a <code>dig</code> command querying a DNS record for a <code>pi-hole.net</code> domain. Notice <strong>status</strong> value <code>NOERROR</code> and the IP address for our requested domain.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-console data-lang=console><span class=line><span class=cl><span class=gp>$</span> dig pi-hole.net @127.0.0.1 -p <span class=m>5335</span>
</span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=go>; &lt;&lt;&gt;&gt; DiG 9.16.22-Raspbian &lt;&lt;&gt;&gt; pi-hole.net @127.0.0.1 -p 5335
</span></span></span><span class=line><span class=cl><span class=go>;; global options: +cmd
</span></span></span><span class=line><span class=cl><span class=go>;; Got answer:
</span></span></span><span class=line><span class=cl><span class=go>;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 6970
</span></span></span><span class=line><span class=cl><span class=go>;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1
</span></span></span><span class=line><span class=cl><span class=go></span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=go>;; OPT PSEUDOSECTION:
</span></span></span><span class=line><span class=cl><span class=go>; EDNS: version: 0, flags:; udp: 1232
</span></span></span><span class=line><span class=cl><span class=go>;; QUESTION SECTION:
</span></span></span><span class=line><span class=cl><span class=go>;pi-hole.net.                   IN      A
</span></span></span><span class=line><span class=cl><span class=go></span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=go>;; ANSWER SECTION:
</span></span></span><span class=line><span class=cl><span class=go>pi-hole.net.            300     IN      A       3.18.136.52
</span></span></span><span class=line><span class=cl><span class=go></span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=go>;; Query time: 19 msec
</span></span></span><span class=line><span class=cl><span class=go>;; SERVER: 127.0.0.1#5335(127.0.0.1)
</span></span></span><span class=line><span class=cl><span class=go>;; WHEN: Thu Jan 27 18:41:51 CET 2022
</span></span></span><span class=line><span class=cl><span class=go>;; MSG SIZE  rcvd: 56
</span></span></span></code></pre></div><h3 id=testing-dnssec>Testing DNSSEC<a hidden class=anchor aria-hidden=true href=#testing-dnssec>#</a></h3><p>Last step before changing our network settings will be testing DNSSEC validation using once again <code>dig</code> command.</p><p>The first command should give us a status report of <code>SERVFAIL</code> and no IP address.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-console data-lang=console><span class=line><span class=cl><span class=gp>$</span> dig sigfail.verteiltesysteme.net @127.0.0.1 -p <span class=m>5335</span>
</span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=go>; &lt;&lt;&gt;&gt; DiG 9.16.22-Raspbian &lt;&lt;&gt;&gt; sigfail.verteiltesysteme.net @127.0.0.1 -p 5335
</span></span></span><span class=line><span class=cl><span class=go>;; global options: +cmd
</span></span></span><span class=line><span class=cl><span class=go>;; Got answer:
</span></span></span><span class=line><span class=cl><span class=go>;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: SERVFAIL, id: 22604
</span></span></span><span class=line><span class=cl><span class=go>;; flags: qr rd ra; QUERY: 1, ANSWER: 0, AUTHORITY: 0, ADDITIONAL: 1
</span></span></span><span class=line><span class=cl><span class=go></span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=go>;; OPT PSEUDOSECTION:
</span></span></span><span class=line><span class=cl><span class=go>; EDNS: version: 0, flags:; udp: 1232
</span></span></span><span class=line><span class=cl><span class=go>;; QUESTION SECTION:
</span></span></span><span class=line><span class=cl><span class=go>;sigfail.verteiltesysteme.net.  IN      A
</span></span></span><span class=line><span class=cl><span class=go></span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=go>;; Query time: 299 msec
</span></span></span><span class=line><span class=cl><span class=go>;; SERVER: 127.0.0.1#5335(127.0.0.1)
</span></span></span><span class=line><span class=cl><span class=go>;; WHEN: Thu Jan 27 18:03:00 CET 2022
</span></span></span><span class=line><span class=cl><span class=go>;; MSG SIZE  rcvd: 57
</span></span></span></code></pre></div><p>The second command should give us <code>NOERROR</code> and IP address.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-console data-lang=console><span class=line><span class=cl><span class=gp>$</span> dig sigok.verteiltesysteme.net @127.0.0.1 -p <span class=m>5335</span>
</span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=go>; &lt;&lt;&gt;&gt; DiG 9.16.22-Raspbian &lt;&lt;&gt;&gt; sigok.verteiltesysteme.net @127.0.0.1 -p 5335
</span></span></span><span class=line><span class=cl><span class=go>;; global options: +cmd
</span></span></span><span class=line><span class=cl><span class=go>;; Got answer:
</span></span></span><span class=line><span class=cl><span class=go>;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 64024
</span></span></span><span class=line><span class=cl><span class=go>;; flags: qr rd ra ad; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1
</span></span></span><span class=line><span class=cl><span class=go></span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=go>;; OPT PSEUDOSECTION:
</span></span></span><span class=line><span class=cl><span class=go>; EDNS: version: 0, flags:; udp: 1232
</span></span></span><span class=line><span class=cl><span class=go>;; QUESTION SECTION:
</span></span></span><span class=line><span class=cl><span class=go>;sigok.verteiltesysteme.net.    IN      A
</span></span></span><span class=line><span class=cl><span class=go></span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=go>;; ANSWER SECTION:
</span></span></span><span class=line><span class=cl><span class=go>sigok.verteiltesysteme.net. 60  IN      A       134.91.78.139
</span></span></span><span class=line><span class=cl><span class=go></span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=go>;; Query time: 29 msec
</span></span></span><span class=line><span class=cl><span class=go>;; SERVER: 127.0.0.1#5335(127.0.0.1)
</span></span></span><span class=line><span class=cl><span class=go>;; WHEN: Thu Jan 27 18:03:15 CET 2022
</span></span></span><span class=line><span class=cl><span class=go>;; MSG SIZE  rcvd: 71
</span></span></span></code></pre></div><hr><h2 id=pi-hole-settings>Pi-hole settings<a hidden class=anchor aria-hidden=true href=#pi-hole-settings>#</a></h2><p>In your <strong>Pi-hole</strong> web console, navigate to the <em>Settings</em>, then <em>DNS</em>. Make sure to uncheck all upstream DNS servers.</p><p><img loading=lazy src=/images/general/recursive_dns/1.png alt></p><p>Now, scroll down to the second <strong>Upstream DNS Servers</strong> section and specify <code>127.0.0.1#5335</code> as the <strong>Custom DNS (IPv4)</strong>. This means that your <em><strong>Pi-hole</strong></em> will use your recursive DNS server provided by <em><strong>unbound</strong></em>.</p><p><img loading=lazy src=/images/general/recursive_dns/2.png alt></p><p>At last, scroll all the way down and <strong>save</strong> your settings. After pressing the <em>Save</em> button you should see a pop up <em>Info</em> window</p><p><img loading=lazy src=/images/general/recursive_dns/3.png alt></p><hr><h2 id=validating-our-setup>Validating our setup<a hidden class=anchor aria-hidden=true href=#validating-our-setup>#</a></h2><p>At the time of writing this post, we have been running <em><strong>Pi-hole</strong></em> with <em><strong>unbound</strong></em> for almost 24 hours. We are able to validate that our configuration works from the <em>Upstream servers</em> pie chart, where 65% of all the DNS queries were handled by our local recursive DNS resolver and 20% were cached queries. Remaining 15% of DNS queries were handled by our preconfigured Quad9 upstream server and other public resolver while we were configuring local recursive DNS resolver <em><strong>unbound</strong></em>.</p><p><img loading=lazy src=/images/general/recursive_dns/4.png alt></p><hr><h2 id=resources>Resources<a hidden class=anchor aria-hidden=true href=#resources>#</a></h2><ul><li>Pi-hole - documentation : <a href=https://docs.pi-hole.net/>https://docs.pi-hole.net/</a></li><li>unbound - about : <a href=https://nlnetlabs.nl/projects/unbound/about/>https://nlnetlabs.nl/projects/unbound/about/</a></li><li>unbound - install : <a href=https://docs.pi-hole.net/guides/dns/unbound/>https://docs.pi-hole.net/guides/dns/unbound/</a></li><li>What is DNS? : <a href=https://www.cloudflare.com/learning/dns/what-is-dns/>https://www.cloudflare.com/learning/dns/what-is-dns/</a></li><li>What is recursive DNS? : <a href=https://www.cloudflare.com/learning/dns/what-is-recursive-dns/>https://www.cloudflare.com/learning/dns/what-is-recursive-dns/</a></li><li>DNS server types : <a href=https://www.cloudflare.com/learning/dns/dns-server-types/>https://www.cloudflare.com/learning/dns/dns-server-types/</a></li></ul><hr><p><em>Thank you for reading and we hope you learned something new.</em>_</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://martinkubecka.sk/tags/unbound/>unbound</a></li><li><a href=https://martinkubecka.sk/tags/pi-hole/>pi-hole</a></li><li><a href=https://martinkubecka.sk/tags/privacy/>privacy</a></li><li><a href=https://martinkubecka.sk/tags/self-hosting/>self-hosting</a></li></ul><nav class=paginav><a class=prev href=https://martinkubecka.sk/posts/news_aggregator/><span class=title>« Prev</span><br><span>Self Hosting News Aggregator</span></a>
<a class=next href=https://martinkubecka.sk/posts/malicious-macros/><span class=title>Next »</span><br><span>Weaponizing Malicious Macros</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://martinkubecka.sk>Martin Kubečka</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let b=document.querySelector("#menu-trigger"),m=document.querySelector(".menu");b.addEventListener("click",function(){m.classList.toggle("hidden")}),document.body.addEventListener("click",function(e){b.contains(e.target)||m.classList.add("hidden")})</script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>